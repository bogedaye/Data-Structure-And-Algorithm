## 入侵

由于所有权值均为正，进入一个点后走完它的强连通分量也都要走到

缩强连通分量，然后在缩之后的图上跑DP，缩点之后的点的权值为原来的强连通分量中所有点的权值和。

$f(u)=a_u+\max\{f(v)\}$ 

## 迷宫

一个点能被走到需要两个条件：一个相邻的点被走到并且对应的开关都被激活。

一个点在能被走到之后一直都能被走到。

考虑使用类似拓扑排序的方法，在删掉一个点时访问一下出边看看周围有没有点被解锁，然后解一下锁看看有没有点的锁被解了。

## 切断

建出点双树，每一个点的答案就是删掉这个点后连通块之间的乘积和加上 $n-1$ 。用dfs算一下子树大小。

## 肉夹馍

先跑一遍KMP，求出fa，然后有两种方法：

1. 若 $fa[i]$ 超过 $i$ 的一半，则有循环节 $T=i-fa[i]$ 且长度大于 $i/2$ 的border有 $fa[i],fa[i]-T,fa[i]-2T,fa[i]-3T\cdots$ （直到减到长度刚好大于 $i/2$ ）然后找到里面最接近 $i/2$ 的那个暴力跳一部 $fa$ 。
2. 可以设 $g[i]$ 为前缀 $i$ 的长度小于 $i/2$ 的最长border，然后从 $p=g[i-1]$ 开始跳 $fa$ ，像KMP那样求。如果当前求出来的border正好是 $i/2$ ，那么跳一步 $fa$ 。

## 最长公共前缀

二分答案，比较两个串的哈希值是否相等。

## 组合技

建出Trie图，然后动态规划，记 $f(i,j)$ 为长度为 $i$ 的字符串，当前在节点 $j$ 的combo最大值。

转移：$f(i+1,j.next[c])+=f(i,j)+val(j.next[c])$ 。

注意自动机上一个点的权值除了本身代表的字符串还要加上fail树的祖先的权值。这个可以在DP之前预处理一下。

## 导出子图

如果一个点的度数小于 $k$ ，那么它一定不能在这个导出子图中。

把它删掉，然后继续寻找是否有度数小于 $k$ 的点。

像拓扑排序一样删点，直到无点可删。在剩下的图中找一个最大的连通块。

## 升级

当 $p=q$ 时每一次都成功，答案为 $N$ 。

当 $a=0$ 时每升一级期望要花 $1/P$ 元，答案为 $N/P$ 。

当 $a=N$ 时要一次性成功，成功的概率是 $P^N$ ，答案为 $1/P^N$ 。

剩下的部分设 $f(i)$ 为从 $i$ 级升到 $i+1$ 级期望的代价，那么可以得到

$f(i)=1+(1-P)\sum\limits_{j=i-a}^if(j)$ 。

移一下项

$Pf(i)=1+(1-P)\sum\limits_{j=i-a}^{i-1}f(j)$

$f(i)=1/P+(1/P-1)\sum\limits_{j=i-a}^{i-1}f(j)$

答案为 $\sum\limits_{i=0}^{N-1}f(i)$ ，所以设 $F(i)=\sum\limits_{i=0}^{i}$ ，然后就有

$F(i)-F(i-1)=1/P+(1/P-1)(F(i-1)-F(i-a-1))$

$F(i)=1/P+F(i-1)/P-(1/P-1)F(i-a-1)$

用矩阵快速幂求这个递推即可。

注意前 $a$ 项不满足这个递推式，要暴力算。

另：求线性递推有比矩阵快速幂更好的方法，但是现阶段掌握这个就可以了。

## 摧毁时间线

