## 入侵

由于所有权值均为正，进入一个点后走完它的强连通分量也都要走到

缩强连通分量，然后在缩之后的图上跑DP，缩点之后的点的权值为原来的强连通分量中所有点的权值和。

$f(u)=a_u+\max\{f(v)\}$ 

## 迷宫

一个点能被走到需要两个条件：一个相邻的点被走到并且对应的开关都被激活。

一个点在能被走到之后一直都能被走到。

考虑使用类似拓扑排序的方法，在删掉一个点时访问一下出边看看周围有没有点被解锁，然后解一下锁看看有没有点的锁被解了。

## 切断

建出点双树，每一个点的答案就是删掉这个点后连通块之间的乘积和加上 $n-1$ 。用dfs算一下子树中圆点的个数。

## 肉夹馍

先跑一遍KMP，求出fa，然后有两种方法：

1. 若 $fa[i]$ 超过 $i$ 的一半，则有循环节 $T=i-fa[i]$ 且长度大于 $i/2$ 的border有 $fa[i],fa[i]-T,fa[i]-2T,fa[i]-3T\cdots$ （直到减到长度刚好大于 $i/2$ ）然后找到里面最接近 $i/2$ 的那个暴力跳一部 $fa$ 。
2. 可以设 $g[i]$ 为前缀 $i$ 的长度小于 $i/2$ 的最长border，然后从 $p=g[i-1]$ 开始跳 $fa$ ，像KMP那样求。如果当前求出来的border正好是 $i/2$ ，那么跳一步 $fa$ 。

## 最长公共前缀

二分答案，比较两个串的哈希值是否相等。

## 组合技

建出Trie图，然后动态规划，记 $f(i,j)$ 为长度为 $i$ 的字符串，当前在节点 $j$ 的combo最大值。

转移：$f(i+1,j.next[c])+=f(i,j)+val(j.next[c])$ 。

注意自动机上一个点的权值除了本身代表的字符串还要加上fail树的祖先的权值。这个可以在DP之前预处理一下。

## 导出子图

如果一个点的度数小于 $k$ ，那么它一定不能在这个导出子图中。

把它删掉，然后继续寻找是否有度数小于 $k$ 的点。

像拓扑排序一样删点，直到无点可删。在剩下的图中找一个最大的连通块。

## 升级

当 $p=q$ 时每一次都成功，答案为 $N$ 。

当 $a=0$ 时每升一级期望要花 $1/P$ 元，答案为 $N/P$ 。

当 $a=N$ 时要一次性成功，成功的概率是 $P^N$ ，答案为 $1/P^N$ 。

剩下的部分设 $f(i)$ 为从 $i$ 级升到 $i+1$ 级期望的代价，那么可以得到

$f(i)=1+(1-P)\sum\limits_{j=i-a}^if(j)$ 。

移一下项

$Pf(i)=1+(1-P)\sum\limits_{j=i-a}^{i-1}f(j)$

$f(i)=1/P+(1/P-1)\sum\limits_{j=i-a}^{i-1}f(j)$

答案为 $\sum\limits_{i=0}^{N-1}f(i)$ ，所以设 $F(i)=\sum\limits_{j=0}^{i}f(j)$ ，然后就有

$F(i)-F(i-1)=1/P+(1/P-1)(F(i-1)-F(i-a-1))$

$F(i)=1/P+F(i-1)/P-(1/P-1)F(i-a-1)$

用矩阵快速幂求这个递推即可。

注意前 $a$ 项不满足这个递推式，要暴力算。

另：求线性递推有比矩阵快速幂更好的方法，但是现阶段掌握这个就可以了。

## 摧毁时间线

如果 $z=0$ ，可以想到是区间DP的一个经典模型。

记 $f(i,j)$ 为删去区间 $i$ 到 $j$ ，且此时两端是 $i-1$ 和 $j+1$ 的答案。

设 $v(x,y,z(,w))$ 为最初的时刻 $x,y,z(,w)$ 相邻时删 $y$ 的代价。

转移时需要枚举区间 $i$ 到 $j$ 中最后剩下的一个时刻 $k$ ，

$f(i,j)=\max\limits_{i\le k \le j}\{f(i,k-1)+f(k+1,j)+v(i-1,k,j+1)\}$ 

时间复杂度 $O(n^3)$ 。

子任务 4 中 $z$ 是单减的。既然需要考虑右边的第二个时刻，那么我们就把它记到状态里去。记 $f(i,j,x)$ 表示删去区间 $i$ 到 $j$ （此时区间两端是 $i-1$ 和 $j+1$ ，且 $j+1$ 的右边是 $x$ ）的答案。

这样枚举 $k$ 的时候右边的小区间就是 $f(k+1,j,x)$ ，代价就是 $v(i-1,k,j+1,x)$ 。

那左边怎么办呢？注意在删左边区间的 $k'$ 时算的 $v$ 是 $v(i-1,k',k,*)$ 的形式，而在具体的计算过程中这个 $*$ 只出现在了 $(a_k-z_*)^2$ 一项。由于 $z$ 是单减的，所以想要让这一项尽量大，就要让 $*$ 取到 $k+1$ 或者 $j+1$ 中使得 $(a_k-z_*)^2$ 较大的一个。并且我们可以发现这个 $v$ 是一定可以取到的，因为如果先删左边的 $i$ 到 $k-1$ ，$k$ 右边始终紧挨的就是 $k+1$ ；如果先删右边的 $k+1$ 到 $j$ ，那么在删左边的时候 $k$ 右边紧挨的就是 $j+1$ 。

所以就有

$f(i,j,x)=\max\limits_{1\le k \le j}\{f(i,k-1,*)+f(k+1,j,x)+v(i-1,k,j+1,x)\}$ ，其中 $*$ 是一个根据 $k$ 和 $j$ 确定的值，定义在上文中。

时间复杂度 $O(n^4)$ 。

当 $z$ 没有规律的时候，$*$ 就有可能取到 $k+1$ 到 $j+1$ 之间的任意一个值。这时就可以预处理使得 $(a_k-z_*)^2$ 最大的 $*$ 了？不对！那个 $*$ 可能在接触到 $k$ （和 $k$ 靠在一起）之前就被删掉了！所以我们还要在状态里多记录一维 $d(i\le d\le j+1)$ ， 表示在删的过程中 $[i,d-1]$ 中的所有时刻都在 $d$ 之前被删去。当 $d$ 等于 $j+1$ 时该条件一定能满足，所以此时 $k$ 可以枚举到 $[i,j]$ 中的任意元素；否则 $k$ 不能小于 $d$ ，因为如果这样那么 $d$ 就不满足在删去 $[i,d-1]$ 之后删去了。此外还要枚举一个 $d'$ 表示右边的区间删的过程中 $d'$ 和 $k$ 靠在一起留给左边用。

所以当 $i< d\le j$ 时有

$f(i,j,d,x)=\max\limits_{d\le k\le j,k+1\le d'\le j+1}\{f(i,k-1,d,d')+f(k+1,j,d',x)+v(i-1,k,j+1,x)\}$

当 $d=j+1$ 或 $i$ 时有

$f(i,j,d,x)=\max\limits_{i\le k\le j,k+1\le d' \le j+1}\{f(i,k-1,i,d')+f(k+1,j,d',x)+v(i-1,k,j+1,x)\}$ 。

答案是 $f(1,n,1,n+2)$ 。（记得开够数组）

状态 $O(n^4)$ ，转移 $O(n^2)$ ，所以复杂度是 $O(n^6)$ 。

注意到 $i\le d \le k \le d' \le j+1 \le x$ ，所以有 $1/720$ 的常数，可以通过 $n=60$ 的数据。



